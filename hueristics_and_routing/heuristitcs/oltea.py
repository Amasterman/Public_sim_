# Initial setup
import math
import time
import argparse

import csv

import matplotlib.pyplot as plt
import numpy as np
from math import radians, sin, cos, sqrt, atan2

import Buses as Bus
import Passenger as Pass
import Route as Route
import Stops as Stop


import logging
import pdb

# Configure logging
logging.basicConfig(filename='oltea.log', level=logging.INFO)

from test import *

# Area of longitude and latitude of the greater Southampton area [Better way to define?]
minlat = 50.8255000
minlon = -1.6263000
maxlat = 51.0142000
maxlon = -1.0873000

# Passenger bookings in advance within a dynamic system
passenger_bookings = []

passenger_transfers = []

# List of stop locations
list_of_stops = []

# Stop importer; IN XML scraped from www.openstreetmap.org OUT List of stop objects
# Open file with CSV reader
with open("XML_to_CSV_OUT.CSV", newline='') as csvfile:
    # Skip header line
    next(csvfile)

    # Break count will limit the amount of stops imported. << means all included
    
    count = 0

    # Begin reading the CSV using the "," as a separator (Note the XML scraper sanitizes the inputs)
    for row in csvfile:
        row = row.split(',')

        # Creates a stop object using the rows as parameters. Currently very inflexible.
        temp_stop = Stop.Stop(row[0], row[1], row[2], row[3], row[4], row[5], row[6], row[7], row[8], row[9], row[10],
                              row[11], row[12], row[13], row[14], row[15], row[16], row[17], row[18], row[19], row[20],
                              row[21], row[22], row[23], count)

        # Append stop to list of stops
        list_of_stops.append(temp_stop)

        # Keep track of the count and break if break count met
        count = count + 1
        if break_count == count:
            break

# Close the CSV writer
csvfile.close()

# count list entries
no_stops = len(list_of_stops)

# -----------------------  Stop relations

# Psudo-array of time between stops. Indexed in MxM
stop_relations = []

# Initialze the psudo-array
for i in range(0, no_stops):
    stop_relations.append([])
    for j in range(0, no_stops):
        stop_relations[i].append("")

# Reset temp variables
i = 0
j = 0

# Open file generated by ProjectOSM
with open("route_durations.CSV", newline='') as csvfile:
    # for row in csvfile:
    # row = row.split(',')
    # j = 0
    # for elements in row:
    #  stop_relations[i][j] = elements
    #   j += 1
    # i += 1

    # Set up reader to read directly from file into an array
    reader = csv.reader(csvfile)
    rows = list(reader)
    for g in range(0, no_stops):
        for f in range(0, no_stops):
            stop_relations[g][f] = rows[g][f]

# -----------------------  Bus settings

# List of vehicles, could be renamed in future to reflect the diffrent vehicles
list_of_buses = []

# Depo is the start and stop position of the buses
# TODO Replace ths random selector with the data set information,
#  might need to still need to have some randomness as there are multiple depos on the map
depo = list_of_stops[rnd.randint(0, no_stops)]

# Random bus generator
# TODO Need to get some more info on the buses in the area, unilink and bluestar maybe?
for i in range(0, no_buses):
    # Generate vehicle with random parameters, also potential to be renamed
    temp_bus = Bus.Buses(i, depo, rnd.randint(4, max_bus_cap), rnd.randint(30, 70),
                         rnd.randint(1, 4), depo)

    # Append to list
    list_of_buses.append(temp_bus)

# -----------------------  Passenger settings

# List of passengers
list_of_passengers = []

# TODO All of this is subject to change, this data is kinda unknowable until the surveys are complete



# Two versions for static and dynamic versions. Decided by the preivously declared global variable.
if dynamic:
    # Generate up to the target number of passengers
    for i in range(0, no_passengers):
        # Generate random passenger data including if the trip has been booked in advance
        temp_passenger = Pass.Passenger(i, rnd.uniform(minlat, maxlat), rnd.uniform(minlon, maxlon),
                                        rnd.uniform(minlat, maxlat),
                                        rnd.uniform(minlon, maxlon), rnd.randint(1, 4), rnd.randint(1, 100),
                                        rnd.randint(1, 3), rnd.randint(1, 1000), rnd.randint(2000, 10000),
                                        bool(random.getrandbits(1)), max_lateness)

        # Append to list of passengers
        list_of_passengers.append(temp_passenger)
else:
    # Generate random passenger data the prebooked flag is set to 1
    for i in range(0, no_passengers):
        temp_passenger = Pass.Passenger(i, rnd.uniform(minlat, maxlat), rnd.uniform(minlon, maxlon),
                                        rnd.uniform(minlat, maxlat),
                                        rnd.uniform(minlon, maxlon), rnd.randint(1, 4), rnd.randint(1, 100),
                                        rnd.randint(1, 3), rnd.randint(1, 1000), rnd.randint(2000, 10000), 1,
                                        max_lateness)

        # Append to list of passengers
        list_of_passengers.append(temp_passenger)

# ----------------------- Ant Colony settings

# Time metric for the algorithm
simTime = 0

# alpha and beta hyper parameters for tuning
a_hyp = 2
b_hyp = 2

# Stinky bois smell rate (Pheromone drop amount)
Q_const = 1

# Pheromone trails
pheromone_trails = []

# Initialize the pheromone trial pseudo-array with very high values (May need to increase not sure)
for i in range(0, no_stops):
    pheromone_trails.append([])
    for j in range(0, no_stops):
        pheromone_trails[i].append(2000)

# Stop probabilities stop_probs[bus,stop,stop]
stop_probs = []

# Initialise the stop probabilities pseudo-array
for b in range(0, no_buses):
    stop_probs.append([])
    for i in range(0, no_stops):
        stop_probs[b].append([])
        for j in range(0, no_stops):
            stop_probs[b][i].append(np.longdouble(0))

# ----------------------- Dynamic setup

# Two lists; passengers booked more than a day in advance/repeat trips, and new requests
passenger_booked = []
passenger_not_booked = []

# ----------------------- Consensus Setup

# Delta Hyper parameter nbOpt lookahead steps
delta = 10

# nbOpt time, From the offline variant
nbOpt = 10

# d as found in the literature
d = 10

# Schedule as defined in the literature
schedule = None

# ---------------------- Passenger grouping

# passenger influence range in coord ranges? Dunno how thats gonna pan out
passenger_influence_range = 0.2


# run the system on the provided method and time the time it takes to run
def run(method):
    # Take the computer time before the run
    start_time = time.perf_counter()

    # Dived the selection by dynamic and static
    if dynamic:
        # Init Dynamic
        int_dynamic()

        # Switch statement for selecting the heuristic
        # Ok no switch statment thats in python 3.10 and im not updatitng and breaking everything again
        if method == "greedy":
            return greedy_online()

        elif method == "ant":
            return ant_colony_online()

        elif method == "consensus":
            return concensus_online()
        pass

    else:

        # Init Static
        list_of_active_stops, passenger_bookings = ini_static()

        # Switch statement for selecting the heuristic
        if method == "greedy":
            return greedy_offline(list_of_active_stops, passenger_bookings)

        elif method == "ant":
            return ant_colony(list_of_active_stops)

        elif method == "consensus":
            return consensus()

        pass

    # Take the differance between the start time and the current clock time to get the run time
    run_time = time.perf_counter() - start_time
    print("Method " + method + " finished in " + str(run_time))


def int_dynamic():
    # Check through passengers for those who have booked in advance vs appear
    # Populate the the lists based on the booked value
    for i in range(0, no_passengers):
        if list_of_passengers[i].booked:
            passenger_booked.append(list_of_passengers[i])
        else:
            passenger_not_booked.append(list_of_passengers[i])

    # The dynamically appearing passengers need a time to appear
    generate_booking_times(passenger_not_booked)


def serve_new_booking(current_time, active_passengers):
    temp_new_passenger = []

    # Iterate through the non booked passengers and serve any passengers that have arrived in the time that have not
    for passenger in passenger_not_booked:
        if passenger not in active_passengers and passenger.booking_time() < current_time:
            temp_new_passenger.append(passenger)

    return temp_new_passenger


def ini_static():

    for i in range(0, no_passengers):
        if list_of_passengers[i].booked:
            passenger_booked.append(list_of_passengers[i])

    # Retrieve the stops that have a passenger waiting and add start and stops to the booking register
    list_of_active_stops, passenger_bookings = user_stops()
    # clusters=create_clusters(list_of_passengers)
    # list_of_active_stops, passenger_bookings = calculate_pickup_locations(clusters, list_of_stops)

    return list_of_active_stops, passenger_bookings


def group_riders(passengers):
    pass


def generate_booking_times(passengers):
    # booking times can appear either at the moment they want to be picked up or a percentage in advance (lets start
    # with 30%?

    roll_preeminence = 0
    roll_prebook = 0

    passenger_preeminence_percent = 50
    passenger_prebook_percentage = .30

    for passenger in passengers:
        roll_preeminence = random(0, 100)
        if roll_preeminence < passenger_preeminence_percent:
            passenger.set_booking_time(passenger.pickup_time)
        else:
            roll_prebook = random(0, passenger_prebook_percentage, 0.01)
            passenger.set_booking_time(passenger.pickup_time * (1 + roll_prebook))


# The offline (ie non dynamic) version of the greedy heuristic
# TODO Improve implementation of the heuristic
def greedy_offline(list_of_active_stops, passenger_bookings):
    logging.info("Greedy Offline")
    print(list_of_buses)
    return route_generator(list_of_passengers.copy(), list_of_buses.copy(), list_of_active_stops, depo)


# Define a function to create clusters based on passenger locations
def create_clusters(passengers):
    clusters = []
    for passenger in passengers:
        added_to_cluster = False
        lat=passenger.getNearestStop(list_of_stops).lat
        long=passenger.getNearestStop(list_of_stops).long
        for cluster in clusters:
            if calc_distance(lat,long, cluster['lat'],cluster['long']) <= MAX_CLUSTER_DISTANCE:
                cluster['members'].append(passenger)
                added_to_cluster = True
                break
        if not added_to_cluster:
            clusters.append({'lat': lat,'long':long, 'members': [passenger]})
    return clusters


# Define a function to calculate the central pickup location for each cluster
def calculate_pickup_locations(clusters, route):
    for x in range(0, len(list_of_passengers)):
        passenger_bookings.append([])
    pickup_locations = []
    for cluster in clusters:
        nearest_stop = None
        min_distance = math.inf
        for stop in route:
            d = calc_distance(cluster['lat'],cluster['long'],stop.lat,stop.long)
            if d < min_distance:
                nearest_stop = stop
                min_distance = d
        for passenger in cluster['members']:
            passenger_bookings[passenger.id]=[nearest_stop, passenger.getNearestDrop(list_of_stops)]
        pickup_locations.append( nearest_stop)
    return pickup_locations, passenger_bookings

# Return all stops in use for this set of passengers and the booking register
def user_stops():
    # Get the Greedy nearest pick and drop stops
    # TODO improve this away from a greedy method
    for p in passenger_booked:
            print(p.id)
        # if p.shouldWalkToDestination(list_of_stops) == False:
            passenger_bookings.append([p.getNearestStop(list_of_stops), p.getNearestDrop(list_of_stops)])
        # else:
        #     passenger_bookings.append(
        #         [
        #             Stop.Stop(rnd.randint(0, len(list_of_stops) - 1),"name",p.lat,p.long,"","","",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,"","",2),
        #             Stop.Stop(rnd.randint(0, len(list_of_stops) - 1),"name",p.destination_x,p.destination_y,"","","",0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,"","",2)
        #          ])
    

    # Initialize an empty set
    list_of_active_stops = set()

    i=0
    # Take start stop elements from passenger bookings and add to the list of active stops
    for elements in passenger_bookings:
        one, two = elements
        if one not in list_of_active_stops :
            list_of_active_stops.add(one)
        i=i+1
        # if two not in list_of_active_stops:
        #    list_of_active_stops.add(two)

    # Convert set to list
    list_of_active_stops = list(list_of_active_stops)

    # Return list and bookings
    return list_of_active_stops, passenger_bookings


# Validate the passed routes, validation includes route connections, passenger pick up, drop off and bus capacity
# TODO validate the validation on the real data set
def validate_route(passenger_route, bus_route):
    # List of passenger target arrival time, indexed by position
    passenger_stop_arrival = []

    # Save passenger stop arrival time indexed by passenger location
    for p in passenger_booked:
        passenger_stop_arrival.append(p.journey_start_time + p.calcTimeToTravel(p.lat, p.long,
                                                                                passenger_route[p.id][0].lat,
                                                                                passenger_route[p.id][0].long))

    # Check each bus validity
    for bus in range(0, len(bus_route)):

        # Store current bus
        current_bus = bus_route[bus]
        stop_order = []
        passenger_manifest = []
        passengers_carried = []
        bus_arrival = []
        bus_depart = []

        for node in range(0, len(current_bus)):

            # Take current node bus
            current_node = current_bus[node]
            capacity_check = 0

            # Append the information from this node to the relevant lists
            # First append the current stop
            stop_order.append(current_node.getStops())

            # Next the passengers
            passenger_manifest.append(current_node.getPassengers())

            # Then arrival and departures
            bus_arrival.append(current_node.getArrival())
            bus_depart.append(current_node.getArrival() + current_node.getWait())

            # Passenger capacity check
            for passengers in current_node.getPassengers():
                capacity_check = + passengers.capacity_cost
                passengers_carried.append(passengers)

            if capacity_check > list_of_buses[bus].bus_capacity:
                return False

        # print(stop_order)
        # print(passengers_carried)
        # print(passenger_manifest)

        # stop_order = [passenger_route[0][0], passenger_route[0][1], passenger_route[1][0],passenger_route[1][1],
        # passenger_route[2][0], passenger_route[2][1], passenger_route[3][0],passenger_route[3][1]]

        # For every passenger the bus carries validate that there is a route that picks them up and drops them off
        for passengers in passengers_carried:

            # Get the pick up and drop off stops for passenger
            pick = passenger_route[passengers.id][0]
            drop = passenger_route[passengers.id][1]

            # Set picked and dropped flags to false
            picked = False
            dropped = False

            # Check through the stop list and find the pick up stop
            for i in range(0, len(stop_order)):
                if stop_order[i] == pick:
                    picked = True

                    # Check the remain stops for the drop stop
                    for j in range(i, len(stop_order)):
                        if stop_order[j] == drop:
                            dropped = True
                            picked_stop = i
                            dropped_stop = j

            # Break if not picked or dropped
            if not picked or not dropped:
                return False

            # print(picked_stop)
            # print(dropped_stop)

            # Check the stops between the pick up and drop off stops to ensure that the passenger is on board
            for i in range(0, picked_stop):
                if passenger_manifest[i] == passengers:
                    return False

            for i in range(dropped_stop + 1, len(passenger_manifest)):
                if passenger_manifest[i] == passengers:
                    return False

            # Check all other stops to ensure the passenger isn't on board
            for i in range(picked_stop + 1, dropped_stop + 1):
                if passenger_manifest[i] != passengers:
                    return False

            if bus_depart[picked_stop] <= passenger_stop_arrival[passengers.id]:
                return False

            if bus_arrival[bus] >= passengers.dropoff_time:
                return False

    return True

# The utility function is calculated for each passenger and each pair of buses that the passenger can transfer between.
# make the funciton to calculate the utility
def utility(passenger, bus1, bus2):
    # make the weights
    w1 = 1
    w2 = 1
    w3 = 1
    w4 = 1
    w5 = 1
    w6 = 1
    w7 = 1

    # make the variables
    d_p_b1 = calc_distance(passenger.lat, passenger.long, bus1.lat, bus1.long)
    d_b1_b2 = calc_distance(bus1.lat, bus1.long, bus2.lat, bus2.long)
    t_p_b1 = calc_distance(passenger.lat, passenger.long, bus1.lat, bus1.long)
    t_b1_b2 = calc_distance(bus1.lat, bus1.long, bus2.lat, bus2.long)
    # c_b1 = bus1.bus_capacity
    # c_b2 = bus2.bus_capacity

    # # make the binary variable
    # if bus1.bus_capacity > bus2.bus_capacity:
    #     conv = 1
    # else:
    #     conv = 0

    # calculate the utility
    utility = w1 * d_p_b1 + w2 * d_b1_b2 + w3 * t_p_b1 + w4 * t_b1_b2 
    # + w5 * c_b1 + w6 * c_b2 + w7 * conv
    
    print(utility)
    return utility
 
    



# Generate a route that satisfies the passenger pick up and drop off requirements
def route_generator(passengers, buses, stops, depo):
    # Initialize the necessary lists
    non_visited_stops = []
    visited_stops = []
    passengers_picked = set()
    passengers_dropped = set()
    passengers_who_transfer = set()
    
    no_pickup_by_this_bus = {}

    passengers_not_picked = passengers
    current_stop = []
    ind_bus = []
    wait = []
    setoff_time = []
    carried_passengers = []
    
    temp_route = []
    
    until = False

    # For each of the buses append a second dimension to the arrays
    for bus in range(0, len(buses)):
        current_stop.append([])
        #  current_stop[0] the current stop of the bus(id), it ahs only one stop even tho its an array
        ind_bus.append([])
        carried_passengers.append([])
        wait.append([])
        setoff_time.append([])
        non_visited_stops.append(set())
        visited_stops.append(set())
        
        temp_route.append([])

    # Append a third dimention
    for bus in range(0, len(buses)):
        current_stop[bus].append(depo)
        temp_route
        ind_bus[bus] = [Route.Route(depo, 0, 0, [])] # ind_bus[0][5][1] the 1st bus, the6th stop, time
        carried_passengers[bus] = set()
        wait[bus] = 0
        setoff_time[bus] = 0
        non_visited_stops[bus] = set(stops)
        visited_stops[bus] = set()

    # Loop until the conditions are satisfied
    while not until:
        for bus in range(0, len(buses)):
            # If there exist any non-visited stops
            if bool(non_visited_stops[bus]):
                # Get the nearest stop
                near_stop = get_nearest_stop(current_stop[bus][0], non_visited_stops[bus].copy())
           
                         
                # x=near_stop
                # for step in range (0,len(passengers_not_picked)):
                #     exclude=[x]
                #     ok=True
                #     passenger = passengers_not_picked[step]
                #     if(passenger.getNearestStop(stops.copy()).id == near_stop.id):
                #         next_nearest_of_passenger = passenger.getOptimalNearest(list_of_stops,exclude)
                #         while (
                #             calc_distance(current_stop[bus][0].lat, current_stop[bus][0].long, near_stop.lat, near_stop.long) + 
                #             passenger.calcDistanceToStop(near_stop) >
                #             calc_distance(current_stop[bus][0].lat, current_stop[bus][0].long, next_nearest_of_passenger.lat, next_nearest_of_passenger.long) + 
                #             passenger.calcDistanceToStop(next_nearest_of_passenger)):
                #             ok=False
                #             near_stop = next_nearest_of_passenger
                #             exclude.append(near_stop)
                #             next_nearest_of_passenger = passenger.getOptimalNearest(list_of_stops,exclude)
                #         passenger_bookings[passenger.id][0] = near_stop
                #         if(ok==False):
                #             for bus2 in range(0,len(buses)):
                #                 if x in non_visited_stops[bus2]:
                #                     non_visited_stops[bus2].remove(x)
                #                 non_visited_stops[bus2].add(near_stop)

                # if(near_stop.id!=x.id):
                #     stops.remove(x)
                #     stops.append(near_stop)
                    
                # near_stop = get_nearest_stop(current_stop[bus][0], non_visited_stops[bus])
                    
                # Add the stop to the visited stop list and remove it from the non_visited stop list
                visited_stops[bus].add(near_stop)
                for bus2 in range(0, len(buses)):
                    if near_stop in non_visited_stops[bus2]:
                        non_visited_stops[bus2].remove(near_stop)

            temp_list = [] #if theres multiple passengers at the same stop, check all
            
            # Generate the list of carried passengers
            for passenger in carried_passengers[bus]:
                if passenger.getNearestDrop(stops.copy()) == near_stop:
                    temp_list.append(passenger)

            # If the stop is the destination of any passenger on the bus, drop them off
            for passenger in temp_list:
                carried_passengers[bus].remove(passenger)
                if passenger in passengers_picked :
                    passengers_picked.remove(passenger)
                    passengers_dropped.add(passenger)
                    print("\n")
                    print ("<<<<<<<<<<<<<<<<<<< Dropped off passenger", passenger.id, "at stop", str(near_stop.getStopId())[:3],"by bus", bus)

            # If the stop is the nearest stop of any passenger pick them up
            for passenger in passengers:
                    if passenger.getNearestStop(stops.copy()) == near_stop and passenger not in carried_passengers and len(carried_passengers[bus]) <=15:
                        carried_passengers[bus].add(passenger)
                        passengers_picked.add(passenger)
                        passengers_not_picked.remove(passenger)
                        stops.append(passenger.getNearestDrop(list_of_stops))
                        non_visited_stops[bus].add(passenger.getNearestDrop(list_of_stops))
                        print("\n")
                        print (">>>>>>>>>>>>>>>>> Picked up passenger", passenger.id)
                            #    , "at stop", near_stop.getStopId())

            # if not bool(non_visited_stops[bus]) and bool(passengers_picked):
            #     for on_board_passenger in passengers_picked:
            #         if on_board_passenger in carried_passengers[bus]:
            #             near_stop = on_board_passenger.getNearestDrop(stops)

          
            # pdb.set_trace()
            
            list=passengers_picked.copy()
            for passenger in list:
                if passenger in carried_passengers[bus]:
                    for bus2 in range(len(buses)):
                        if bus2!=bus:
                            transfer_rate=utility(passenger,current_stop[bus][0], ind_bus[bus2][-1].getStops())
                            print(int(transfer_rate),"..........................utility")
                            if transfer_rate>40000:
                                passenger_transfers.append(passenger)
                                passengers_not_picked.append(passenger)
                                passengers_picked.remove(passenger)
                                carried_passengers[bus].remove(passenger)
                                non_visited_stops[bus2].add(passenger.getNearestStop(stops.copy()))
                                non_visited_stops[bus].add(passenger.getNearestDrop(stops.copy()))
                                print("passenger",passenger.id,"from bus",bus,"transferred to bus",bus2)

            # Calculate arrival time
            #Worikng on changing to time stamp not calc
            #arrival_time = get_arrival(current_stop[bus][0], near_stop, setoff_time[bus], wait[bus])
            arrival_time = 1
            # TODO This needs some more real data, unilink?
            wait[bus] = wait_time()

            # Append the part of the route to the buses route
            ind_bus[bus].append(Route.Route(near_stop, arrival_time, wait[bus], carried_passengers[bus]))

            # Set current stop to the near_stop
            current_stop[bus][0] = near_stop

            # Set set off time to previous arrival time
            setoff_time[bus] = arrival_time

            # Check all passengers were picked up and dropped off
            if len(passengers_dropped) == len(list_of_passengers) and len(passengers_picked) == 0 and len(
                    passengers_not_picked) == 0:
                until = True

    # print(ind_bus)
    return ind_bus

# These are depreciated in favor of stop relations ---------------------------------------------------------------------
def calc_arrival(stop1, stop2, speed, arrival, wait):
    return arrival + wait + (calc_distance(stop1.lat, stop1.long, stop2.lat, stop2.long) / speed)


# def calc_distance(x1, y1, x2, y2):
    # return math.sqrt(abs(x1 - x2) ** 2 + abs(y1 - y2) ** 2)


def calc_distance(lat1, lon1, lat2, lon2):
    R = 6371  # Radius of the Earth in kilometers

    # Convert latitude and longitude to radians
    lat1, lon1, lat2, lon2 = map(radians, [lat1, lon1, lat2, lon2])

    # Calculate the differences in latitude and longitude
    dlat = lat2 - lat1
    dlon = lon2 - lon1

    # Calculate the Haversine formula
    a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlon / 2) ** 2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))
    d = R * c * 1000  # Distance in meters

    return d


# ----------------------------------------------------------------------------------------------------------------------

# Lookup the time between stops
def get_arrival(stop1, stop2, arrival, wait):
    return arrival + wait + stop_relations[int(stop1.id)][int(stop2.id)]


# Describe the routes of a bus in the console
def explore_bus_route(route, bus):
    # First Describe stop order and arrival time
    for stop in route:
        stop_id = stop.getStops().getStopId()
        stop_arrival = stop.getArrival()
        stop_wait = stop.getWait()

        print("Bus number: " + str(bus) + " arrives at stop: " + str(stop_id)[:3])
        # + " at " +
        #       str(stop_arrival) + " and waits: " + str(stop_wait))


# Describe the routes of a passenger in the console
def explore_passenger_route(route):
    for passenger_id in range(0, len(route)):
        passenger_pick = route[passenger_id][0]
        passenger_drop = route[passenger_id][1]
        # print("Passenger id: " + str(passenger_id) + " is picked up at stop " + str(passenger_pick.getStopId())
        #       + " and is dropped at stop " + str(passenger_drop.getStopId()))


# Get the order of stops the take buses within the route
def get_bus_order(route):
    order = []
    for stop in route:
        order.append(stop.getStops())

    return order

def wait_time():
    return rnd.randint(0, 10000)

def evaluate_soloution(passenger_route, bus_route):
    current_passenger = None
    start = 0
    destination = 0
    total_passenger_travel = 0

    for i in range(0, len(passenger_route)):
        current_passenger = list_of_passengers[i]
        start, destination = passenger_route[i]
        total_passenger_travel += passenger_evaluate(current_passenger, start, destination)

    total_bus_travel = 0

    for j in range(0, len(bus_route)):
        total_bus_travel += bus_evaluate(bus_route[j])

    return total_bus_travel + total_passenger_travel


def passenger_evaluate(passenger, start, destination):
    passenger_start_x = passenger.xcord
    passenger_start_y = passenger.ycord
    passenger_dest_x = passenger.destination_x
    passenger_dest_y = passenger.destination_y

    time_to_start = passenger.calcTimeToTravel(passenger_start_x, start.lat, passenger_start_y, start.lang)
    time_to_dest = passenger.calcTimeToTravel(passenger_dest_x, destination.lat, passenger_dest_y, destination.long)

    return time_to_start + time_to_dest


def bus_evaluate(bus):
    return bus[-1].getArrival()


def calc_visablity(stop_i, stop_j):
    if stop_i != stop_j and float(stop_relations[stop_i.look_up_index][stop_j.look_up_index]) != 0:
        return 1 / float(stop_relations[stop_i.look_up_index][stop_j.look_up_index])
    else:
        return 0

def calc_probablity(stop_candidates):
    for bus in list_of_buses:
        sum_prob_of_stops = 0
        for stop_i in stop_candidates:
            for stop_j in stop_candidates:
                sum_prob_of_stops += (pheromone_trails[stop_i.look_up_index][stop_j.look_up_index] ** a_hyp) * \
                                     (calc_visablity(stop_i, stop_j) ** b_hyp)

        for stop_i in stop_candidates:
            for stop_j in stop_candidates:
                # print(    (((pheromone_trails[stop_i.look_up_index][stop_j.look_up_index] ** a_hyp) * (
                # calcVisablity(stop_i, stop_j) ** b_hyp)) / sum_prob_of_stops ) )
                stop_probs[bus.id][stop_i.look_up_index][stop_j.look_up_index] = \
                    (((pheromone_trails[stop_i.look_up_index][stop_j.look_up_index] ** a_hyp) * (
                            calc_visablity(stop_i, stop_j) ** b_hyp)) / sum_prob_of_stops)
                # print(stop_probs[bus.id][stop_i.look_up_index][stop_j.look_up_index] )
        # print(stop_probs)



def plot(list_of_stops, list_of_passengers, list_of_buses, passenger_bookings, bus_routes):
    # ----------------------  Plot figure

    for i in range(0, len(list_of_stops)):
        plt.plot(list_of_stops[i].lat, list_of_stops[i].long, 'bo', markersize=0.5)
        plt.annotate('%d' % i, (list_of_stops[i].lat + 2, list_of_stops[i].long))

    for i in range(0, len(list_of_passengers)):

        plt.text(list_of_passengers[i].lat, list_of_passengers[i].long, list_of_passengers[i].id, ha="center", va="center")
        plt.text(list_of_passengers[i].destination_x,list_of_passengers[i].destination_y, str(list_of_passengers[i].id)+"*")
        plt.plot(list_of_passengers[i].destination_x, list_of_passengers[i].destination_y, 'gx')
        plt.annotate('p_%d' % i, (list_of_passengers[i].lat + 2, list_of_passengers[i].long))
        plt.annotate('p_%d' % i, (list_of_passengers[i].destination_x + 2, list_of_passengers[i].destination_y))
    
    for i in range(0, len(passenger_bookings)):
            plt.plot([list_of_passengers[i].lat, passenger_bookings[i][0].lat],
                     [list_of_passengers[i].long, passenger_bookings[i][0].long], ':b')

            plt.plot([list_of_passengers[i].destination_x, passenger_bookings[i][1].lat],
                     [list_of_passengers[i].destination_y, passenger_bookings[i][1].long], ':g')

    for i in range(0, len(bus_routes)):
        col = (np.random.random(), np.random.random(), np.random.random())
        for j in range(1, len(bus_routes[i])):

            plt.plot([bus_routes[i][j - 1].lat, bus_routes[i][j].lat],
                     [bus_routes[i][j - 1].long, bus_routes[i][j].long], c=col, linewidth=0.90, marker='D')
    plt.title('Oltea')
    plt.show()

def get_nearest_stop(stop, stop_candidates):
    current_nearest = 100000000000
    near_stop = None
    to_list = list(stop_candidates)
    for destinations in to_list:
        if float(stop_relations[stop.look_up_index][destinations.look_up_index]) <= float(current_nearest) and \
                (destinations != stop):
            current_nearest = stop_relations[stop.look_up_index][destinations.look_up_index]
            near_stop = destinations

    return near_stop

def optimal_schedule(jobs, horizon):
    max_p = " "
    for times in horizon:
        schedule[times] = " "

    ordered_schedule = sorted(schedule, key=lambda schedule: (schedule[x].weight(), schedule[x].arrival_date()))
    for job in ordered_schedule:
        for times in horizon:
            if times <= job.arrival_date + d and schedule[times] == " ":
                if times > max_p:
                    times = max_p

            if max_p != " ":
                if max_p >= job.arrival_date:
                    schedule[max_p] = job
                else:
                    schedule = shuffle(schedule, job, p)
    post_process(schedule, horizon)
    return schedule


def shuffle(schedule, job, p):
    schedule_prime = schedule
    schedule[p] = job
    while p < job.arrival_date:
        min_q = " "
        if p + 1 <= t <= p + d and schedule[t].arrival_date <= p:
            if t <= min_q:
                min_q = t

        if p != " ":
            swap(schedule, p, q)
        else:
            return schedule_prime
    return schedule


def swap(schedule, p, q):
    schedule[p], schedule[q] = schedule[q], schedule[p]


def post_process(schedule, horizon):
    for p in horizon:
        for q in horizon:
            if p < q:
                if feasable_swap(schedule, p, q) and (schedule[p].weight(), schedule[p].arrival_date) < \
                        (schedule[q].weight(), schedule[q].arrival_date):
                    swap(schedule, p, q)


def feasable_swap(schedule, t1, t2):
    return bool(schedule[t1].arrival_date() <= t2 <= schedule[t1].arrival_date() + d) and \
           bool(schedule[t2].arrival_date() <= t1 <= schedule[t2].arrival_date() + d)


def choose_request_ne(jobs, t):
    evalScore = []
    for i in range(0, len(jobs)):
        evalScore[i] = 0

    for i in range(1, (nbOpt / len(jobs))):
        R = jobs * get_sample(t + 1, t + delta)
        T = [t + 1, t + 1 + delta + d]
        for i in range(0, len(jobs)):
            schedule = optimal_schedule(R / jobs(i), T)
            # TODO add job weight
            evalScore[i] = evalScore[i] + schedule[i].weight()
        return argmax(jobs, evalScore)


def choose_request_e(jobs, t):
    eval_score_class = []
    low_class = []
    temp_min_class = 0

    for job_class in jobClasses:
        for job in jobs:
            if job.type == job_class:
                if job.arrival_date() < temp_min_class:
                    lowClass[job_class] = 0

    for i in range(1, nbOpt / len(job_class)):
        R = jobs * get_sample(t + 1, t + delta)
        T = [t + 1, t + 1 + delta + d]
        for job_class in jobClasses:
            schedule = optimal_schedule(R / job_class, T)
            # TODO add job weight
            eval_score_class[job_class] = eval_score_class[job_class]

        c_prime = max(eval_score_class)
        # j(c*)
        return


def choose_request_c(jobs, t):
    c = 0
    eval_score = []

    for job in jobs:
        c[job] = 0

    for i in range(1, nbOpt):
        R = jobs * get_sample(t + 1, t + delta)
        schedule = optimal_schedule(R, [t, t + delta + d])
        c[schedule(t)] = c[schedule(t)] + 1

    return argmax(jobs, c(j))


def choose_request_CE(jobs, t):
    c = 0
    for job in jobs:
        c[job] = 0

    for i in s_c:
        R = jobs * get_sample(t + 1, t + delta)
        schedule = optimal_schedule(R, [t, t + delta + d])
        c[schedule(t)] = c[schedule(t)] + 1
    P = argmax(k, jobs, c(j))

    for job in P:
        eval_score[job] = 0

    for i in range(1, s_e):
        R = P * get_sample(t + 1, t + delta)
        T = [t + 1, t + 1 + delta + d]
        for job in P:
            schedule = optimal_schedule(R / job, T)
            eval_score[job] = eval_score[job] + schedule[i].weight()

    return argmax(P, eval_score)


def get_sample(bt, et):
    pass


def cm_policy():
    schedule = ["idle"]
    pointer = 0

    for i in range(0, len(task)):
        schedule.append("idle")

    for job_class in job_classes:
        for task in job_class:
            for i in range(0, len(schedule)):
                if schedule[-i] == "idle":
                    pass


###------------- Main run Start

# -----------------------  Random settings
rnd = np.random

parser=argparse.ArgumentParser()
parser.add_argument('--seed', type=int, default=None, help='random seed')
args=parser.parse_args()

if args.seed is not None:
    rnd.seed(args.seed)

routes = run("greedy")

explore_passenger_route(passenger_bookings)


bus_routes = []

for i in range(0, len(routes)):
    bus_routes.append(get_bus_order(routes[i]))
    print(explore_bus_route(routes[i], i))
# bus_routes = [getBusOrder(routes[0]), getBusOrder(routes[1]), getBusOrder(routes)]

plot(list_of_stops, list_of_passengers, list_of_buses, passenger_bookings, bus_routes)

# run(None)
